{"meta":{"title":"Younfor","subtitle":"随心而笔","description":"时间是最好的老师","author":"younfor","url":"http://younfor.com"},"pages":[{"title":"","date":"2018-06-09T15:01:57.000Z","updated":"2018-06-09T15:01:23.000Z","comments":true,"path":"baidu_verify_vYMDsKEXTK.html","permalink":"http://younfor.com/baidu_verify_vYMDsKEXTK.html","excerpt":"","text":"vYMDsKEXTK"},{"title":"about","date":"2015-12-30T16:32:43.000Z","updated":"2018-06-09T12:57:10.000Z","comments":true,"path":"about/index.html","permalink":"http://younfor.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-09T11:54:04.000Z","updated":"2018-06-09T12:57:10.000Z","comments":true,"path":"tags/index.html","permalink":"http://younfor.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Go基础语法.md","slug":"Go基础语法","date":"2018-06-09T13:11:17.000Z","updated":"2018-06-09T14:33:27.000Z","comments":true,"path":"Go基础语法/","link":"","permalink":"http://younfor.com/Go基础语法/","excerpt":"","text":"1. 编码风格1.1 gofmt一般会自动规范代码风格 1.2 注释&amp;驼峰命名/ 需要注释的内容 / 1.3 包名1import \"bytes\" 2. 变量2.0 常量12345678910111213type ByteSize float64const ( _ = iota KB ByteSize = 1 &lt;&lt; (2 * iota) MB GB)// 主函数func main() &#123; fmt.Println(\"Hello World!\") fmt.Println(\"size %f\", GB) // size %f 64&#125; 2.1 声明1234var ( ErrInternal = errors.New(\"error1\") ErrInternal2 = errors.New(\"error2\")) 2.2 初始化Go语言提供了New和make new1234567891011121314151617181920// 0值初始化type SyncedBuffer struct &#123; lock sync.Mutex buffer bytes.Buffer&#125;p := new(SyncedBuffer) // type *SyncedBuffervar v SyncedBuffer // type SyncedBuffer// 如果是构造函数func NewFile(fd int, name string) *File &#123; if fd &lt; 0 &#123; return nil &#125; f := File&#123;fd, name, nil, 0&#125; // 如果不按顺序，就需要加名字 return &amp;f&#125;// 复合字面可以初始化多种结构a := [...]string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125;s := []string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125;m := map[int]string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125; make`make一般用于初始化切片，映射，信道123make([]int, 10, 100)// 一般用法, 返回的不是指针v := make([]int, 100) 3. 分支循环3.1 if12345678if i &lt; f() &#123; g()&#125;if err := file.Chmod(0664); err != nil &#123; log.Print(err) return err&#125; 3.2 for1234567891011121314151617181920212223242526for init; condition; post &#123;&#125;for condition &#123;&#125;for &#123;&#125;// 举例sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125;// 遍历复合结构for key, value := range oldMap &#123; newMap[key] = value&#125;// 只遍历第一个for key := range oldMap &#123;&#125;// 只遍历第二个for _, value := range array &#123;&#125;// 遍历字符串for pos, char := range \"日本 \\ x80 语\" &#123; fmt.Printf()&#125;// 反转数字for i, j := 0, len(a) - 1; i &lt; j; i,j = i+1, j-1 &#123; a[i], a[j] = a[j], a[i]&#125; 3.3 switch12345678910111213141516171819202122switch &#123;case '0' &lt;= c &amp;&amp; c &lt;= '9' : return c - '0'case 'a' &lt;= c &amp;&amp; c &lt;= 'f' : return c - 'a' + 10&#125;// 处理相同条件switch c &#123;case 'a', 'b', 'c': return true&#125;// 判断类型var t interface&#123;&#125;t = getType()switch t := t.(type) &#123;default : fmt.Printf(\"%T\", t)case bool : fmt.Printf(\"boolean %t\\n\", t)case int: fmt.Printf(\"integer %d\\n\", t)&#125; 4. 函数4.1 多值返回1func (file *File) Write(b []byte) (n int, err error) 4.2 defer无论何种路径都能返回，如果定义多个按定义顺序相反顺序执行 5. 切片(数组)123456789// 切片是按值传递，但是底层可能是同一份数组// 二维切片type Transform [3][3]float64type LinesOfText [][]bytetest := LinesOfTest&#123; []byte(\"abc\"), []byte(\"abc\"), []byte(\"abc\"),&#125; 5.1 append12345678// 增加元素x := []int&#123;1,2,3&#125;x = append(x, 4, 5, 6)fmt.Println(x)// 增加切片y := []int&#123;1,2,3&#125;x = append(x, y...)fmt.Println(x) 6. Map映射1234567891011121314attend := map[string]bool&#123; \"Ann\" : true, \"Joe\" : true, ...&#125;// 判断是否存在var seconds intvar ok boolseconds, ok = timeZone[tz]if _, ok := timeZone[tz]; ok &#123; doSomething()&#125;// 删除映射delete(timeZone, \"PDT\") 初始化方式：File{fd, name, nil, 0}File{fd: fd, name: name}make([]int, 100) 7. 函数7.1 init在变量初始化之后，导入包初始化之后，就会初始化`以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。 8. 接口8.1 断言12345str, ok := value.(string)if ok &#123; fmt.Printf(\"\")&#125; else &#123;&#125; 8.2 内嵌1234567891011121314151617// 接口type Reader interface &#123; Read(p []byte) (n int, err error)&#125;type Writer interface &#123; Write(p []byte) (n int, err error)&#125;type ReaderWriter interface &#123; Reader Writer&#125;// 结构体type ReaderWriter struct &#123; *Reader *Writer&#125; 9 并发9.1 chan123cj := make(chan int) // 无缓冲信道cj := make(chan int, 0) // 无缓冲信道cj := make(chan *os.File, 100) // 指向文件指针的带缓冲信道 9.2 例子12345678910111213141516171819c := make(chan int)go func() &#123; list.Sort() c &lt;- 1&#125;()doSomethingForAWhile()&lt;- c// 考虑带缓冲的任务func Serve(queue chan *Request) &#123; for req := range queue &#123; req := req sem &lt;- 1 go func() &#123; process(req) &lt;-sem &#125;() &#125;&#125; 10 panic&amp;recover","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://younfor.com/categories/Go语言/"}],"tags":[]},{"title":"Go高级编程.md","slug":"Go高级编程","date":"2018-06-09T03:11:17.000Z","updated":"2018-06-09T15:13:00.000Z","comments":true,"path":"Go高级编程/","link":"","permalink":"http://younfor.com/Go高级编程/","excerpt":"","text":"https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-04-memory.html 1.数组1.1数组定义方式1234567var a [3]int // 定义一个长度为3的int类型数组, 元素全部为0var b = [...]int&#123;1, 2, 3&#125; // 定义一个长度为3的int类型数组, 元素为 1, 2, 3var c = [...]int&#123;2: 3, 1: 2&#125; // 定义一个长度为3的int类型数组, 元素为 0, 2, 3var d = [...]int&#123;1, 2, 4: 5, 6&#125; // 定义一个长度为6的int类型数组, 元素为 1, 2, 0, 0, 5, 6 1.2数组指针123456789101112131415var a = [...]int&#123;1, 2, 3&#125; // a 是一个数组var b = &amp;a // b 是指向数组的指针fmt.Println(a[0], a[1]) // 打印数组的前2个元素fmt.Println(b[0], b[1]) // 通过数组指针访问数组元素的方式和数组类似for i, v := range b &#123; // 通过数组指针迭代数组的元素 fmt.Println(i, v)&#125; 1.3数组遍历1234567891011121314151617for i := range a &#123; fmt.Printf(\"b[%d]: %d\\n\", i, b[i])&#125;for i, v := range b &#123; fmt.Printf(\"b[%d]: %d\\n\", i, v)&#125;for i := 0; i &lt; len(c); i++ &#123; fmt.Printf(\"b[%d]: %d\\n\", i, b[i])&#125; 1.4函数数组、管道数组1234567891011121314151617181920212223// 图像解码器数组var decoder1 [2]func(io.Reader) (image.Image, error)var decoder2 = [...]func(io.Reader) (image.Image, error)&#123; png.Decode, jpeg.Decode,&#125;// 接口数组var unknown1 [2]interface&#123;&#125;var unknown2 = [...]interface&#123;&#125;&#123;123, \"你好\"&#125;// 管道数组var chanList = [2]chan int&#123;&#125; 1.5空数组长度为0的数组在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于强调某种特有类型的操作时避免分配额外的内存空间，比如用于管道的同步操作：1234567891011c1 := make(chan [0]int)go func() &#123; fmt.Println(\"c1\") c1 &lt;- [0]int&#123;&#125;&#125;()&lt;-c1 在这里，我们并不关心管道中传输数据的真实类型，其中管道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组来作为管道类型可以减少管道元素赋值时的开销。当然一般更倾向于用无类型的匿名结构体代替：1234567891011c2 := make(chan struct&#123;&#125;)go func() &#123; fmt.Println(\"c2\") c2 &lt;- struct&#123;&#125;&#123;&#125; // struct&#123;&#125;部分是类型, &#123;&#125;表示对应的结构体值&#125;()&lt;-c2 2.字符串2.1类似切片字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串面值常量通常是对应同一个字符串常量）：12345678910s := \"hello, world\"hello := s[:5]world := s[7:]s1 := \"hello, world\"[:5]s2 := \"hello, world\"[7:] 和数组一样，内置的len和cap函数返回相同的结果，都对应字符串的长度。也可以通过reflect.StringHeader结构访问字符串的长度（这里只是为了演示字符串的结构，并不是推荐的做法）：12345fmt.Println(\"len(s):\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len) // 12fmt.Println(\"len(s1):\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s1)).Len) // 5fmt.Println(\"len(s2):\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s2)).Len) // 5 3.切片(slice)1234567891011121314151617181920212223var ( a []int // nil切片, 和 nil 相等, 一般用来表示一个不存在的切片 b = []int&#123;&#125; // 空切片, 和 nil 不相等, 一般用来表示一个空的集合 c = []int&#123;1, 2, 3&#125; // 有3个元素的切片, len和cap都为3 d = c[:2] // 有2个元素的切片, len为2, cap为3 e = c[0:2:cap(c)] // 有2个元素的切片, len为2, cap为3 f = c[:0] // 有0个元素的切片, len为0, cap为3 g = make([]int, 3) // 有3个元素的切片, len和cap都为3 h = make([]int, 2, 3) // 有2个元素的切片, len为2, cap为3 i = make([]int, 0, 3) // 有0个元素的切片, len为0, cap为3)``## 3.1添加切片 var a []int a = append(a, 1) // 追加1个元素 a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式 a = append(a, []int{1,2,3}…) // 追加一个切片, 切片需要解包 1`在容量不足的情况下，append的操作会导致重新分配内存，从而导致巨大的内存分配和复制数据代价` var a = []int{1,2,3} a = append([]int{0}, a…) // 在开头添加1个元素 a = append([]int{-3,-2,-1}, a…) // 在开头添加1个切片1234567891011```var a []inta = append(a[:i], append([]int&#123;x&#125;, a[i:]...)...) // 在第i个位置插入xa = append(a[:i], append([]int&#123;1,2,3&#125;, a[i:]...)...) // 在第i个位置插入切片a = append(a, x...) // 为x切片扩展足够的空间copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置copy(a[i:], x) // 复制新添加的切片 3.2删除切片需要重新赋值切片防止内存泄漏123456789func FindPhoneNumber(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) b = regexp.MustCompile(\"[0-9]+\").Find(b) return append([]byte&#123;&#125;, b...) // 这里&#125; 删除切片有时候会影响GC12345678var a []*int&#123; ... &#125;a = a[:len(a)-1] // 本删除的最后一个元素依然被引用, 可能导致GC操作被阻碍var a []*int&#123; ... &#125;a[len(a)-1] = nil // GC回收最后一个元素内存a = a[:len(a)-1] // 从切片删除最后一个元素 可以用copy和append组合可以避免创建中间的临时切片，同样是完成添加元素的操作：12345a = append(a, 0) // 切片扩展1个空间copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置s[i] = x // 设置新添加的元素 第一句append用于扩展切片的长度，为要插入的元素留出空间。第二句copy操作将要插入位置开始之后的元素向后挪动一个位置。第三句真实地将新添加的元素赋值到对应的位置。操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片。用copy和append组合也可以实现在中间位置插入多个元素(也就是插入一个切片):12345a = append(a, x...) // 为x切片扩展足够的空间copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置copy(a[i:], x) // 复制新添加的切片 也可以用copy完成删除开头的元素：12345a = []int&#123;1, 2, 3&#125;a = a[:copy(a, a[1:])] // 删除开头1个元素a = a[:copy(a, a[N:])] // 删除开头N个元素 对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用append或copy原地完成：1234567891011a = []int&#123;1, 2, 3, ...&#125;a = append(a[:i], a[i+1:]...) // 删除中间1个元素a = append(a[:i], a[i+N:]...) // 删除中间N个元素a = a[:copy(a[i:], a[i+1:])] // 删除中间1个元素a = a[:copy(a[i:], a[i+N:])] // 删除中间N个元素 4.并发模型4.1加锁12345678var total struct &#123; sync.Mutex value int&#125;通过sync.lock()和sync.Done() 4.2原子1234567891011121314151617181920212223242526272829303132333435363738import ( \"sync\" \"sync/atomic\")//用法：func worker(wg *sync.WaitGroup) &#123; defer wg.Done() var i uint64 for i = 0; i &lt;= 100; i++ &#123; atomic.AddUint64(&amp;total, i) &#125;&#125;func main() &#123; var wg sync.WaitGroup wg.Add(2) go worker(&amp;wg) go worker(&amp;wg) wg.Wait()&#125; 4.3单例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455我们可以将通用的代码提取出来，就成了标准库中sync.Once的实现：type Once struct &#123; m Mutex done uint32&#125;func (o *Once) Do(f func()) &#123; if atomic.LoadUint32(&amp;o.done) == 1 &#123; return &#125; o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; defer atomic.StoreUint32(&amp;o.done, 1) f() &#125;&#125;基于sync.Once重新实现单件模式：var ( instance *singleton once sync.Once)func Instance() *singleton &#123; once.Do(func() &#123; instance = &amp;singleton&#123;&#125; &#125;) return instance&#125; 4.4带缓冲chan测试了下才知道原来&lt;-chan int 像这样的只能接收值chan&lt;- int 像这样的只能发送值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var limit = make(chan int, 3)func main() &#123; for _, w := range work &#123; go func() &#123; limit &lt;- 1 w() &lt;-limit &#125;() &#125; select&#123;&#125;&#125;func main() &#123; done := make(chan int, 10) // 带 10 个缓存 // 开N个后台打印线程 for i := 0; i &lt; cap(done); i++ &#123; go func()&#123; fmt.Println(\"你好, 世界\") done &lt;- 1 &#125;() &#125; // 等待N个后台线程完成 for i := 0; i &lt; cap(done); i++ &#123; &lt;-done &#125;&#125;//其实也可以用sync.WaitGroup 4.5 select12345678910111213141516171819202122232425262728293031323334基于select实现的管道的超时判断： select &#123; case v := &lt;-in: fmt.Println(v) case &lt;-time.After(time.Second): return // 超时 &#125;通过select的default分支实现非阻塞的管道发送或接收操作： select &#123; case v := &lt;-in: fmt.Println(v) default: // 没有数据 &#125;通过select来阻止main函数退出：func main() &#123; // do some thins select&#123;&#125;&#125; 但是管道的发送操作和接收操作是一一对应的，如果要停止多个Goroutine那么可能需要创建同样数量的管道，这个代价太大了。其实我们可以通过close关闭一个管道来实现广播的效果，所有从关闭管道接收的操作均会收到一个零值和一个可选的失败标志。12345678910111213141516171819202122232425262728293031323334353637383940func worker(cannel chan bool) &#123; for &#123; select &#123; default: fmt.Println(\"hello\") // 正常工作 case &lt;-cannel: // 退出 &#125; &#125;&#125;func main() &#123; cancel := make(chan bool) for i := 0; i &lt; 10; i++ &#123; go worker(cancel) &#125; time.Sleep(time.Second) close(cancel)&#125; 5.异常异常必须放在defer func () {}()","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://younfor.com/categories/Go语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://younfor.com/tags/Go/"}]}]}