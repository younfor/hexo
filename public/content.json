{"meta":{"title":"Younfor","subtitle":"随心而笔","description":"时间是最好的老师","author":"younfor","url":"http://younfor.com"},"pages":[{"title":"about","date":"2015-12-30T16:32:43.000Z","updated":"2018-06-11T04:48:37.687Z","comments":true,"path":"about/index.html","permalink":"http://younfor.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-09T11:54:04.000Z","updated":"2018-06-11T04:48:37.688Z","comments":true,"path":"tags/index.html","permalink":"http://younfor.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL高级知识","slug":"MySQL知识","date":"2018-06-14T07:21:17.000Z","updated":"2018-06-14T07:42:01.926Z","comments":true,"path":"MySQL知识/","link":"","permalink":"http://younfor.com/MySQL知识/","excerpt":"","text":"系统命令 show databases show tables show columns from customers show status显示服务器状态信息 show create database / show create table xxx显示创表语句查询 select xx from table order by column1 desc, column2;按column1降序，column2升序，默认大小写是一样的 select xx from table order by column limit 1先排序column，再取第一个 where xxx order by提示：order by 必须放where之后，where默认不区分大小写 where xxx is null空值检查 and or操作符要打括号，and优先级更高 in not 12where xxx in (a,b,c) // 也可以嵌套select语句where xxx not in (a,b,c) like 12select prob_name from products where prod_name like 's%e' // 其中%表示任意字符出现任意次select xxx where xxx like '_ se' // 其中'_'匹配一个字符 regexp (正则)^$可以表示单词的开始和结尾，.表示单个字符 1select xxx where xxx regexp [binary] 'hello .000 | abcd [123][5-6]\\\\.' 其中binary可选参数，表示是否区分大小写其中|表示或者，[]表示匹配里面的多个字符之一\\\\.表示匹配. concat 1select concat (var1, 'a', var2) from table; //拼接起来 as (别名) upper left length locate lower ltrim right substring CurDate CurTime当前日期，当前时间 Now当前日期+时间 avg, count, max, min, sum求平均，求总数，最大值等 group by1select count(*) from table group by xxx having count(*) &gt; 2 order by xxx; 联结表、组合查询 默认笛卡尔积检索出的行数为第一个表乘以第二个表的行数 inner join table on xx = xx 类似默认笛卡尔积 left outer join 和 right outer joinCROSS JOIN 笛卡尔乘积（所有可能的行对）INNER JOIN 仅对满足连接条件的CROSS中的列LEFT OUTER JOIN 一个表满足条件的行，和另一个表的所有行RIGHT OUTER JOIN 与LEFT相同，但两个表的角色互换FULL OUTER JOIN LEFT OUTER 和 RIGHT OUTER中所有行的超集 union / union all其中union会去重数据插入、更新、删除 插入多条数据1insert into table(表字段) values(xxx),(xxx); 索引普通索引创建方式如下：123456789101112// 直接创建索引CREATE INDEX index_name ON table(column(length))// 修改表结构的方式添加索引ALTER TABLE table_name ADD INDEX index_name ON (column(length))// 创建表的时候同时创建索引CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , PRIMARY KEY (`id`), INDEX index_name (title(length)) )// 删除索引DROP INDEX index_name ON table 唯一索引(和主键索引唯一的区别是可以为null)12345678910// 直接创建索引CREATE UNIQUE INDEX index_name ON table(column(length))// 修改表结构的方式添加索引ALTER TABLE table_name ADD UNIQUE index_name ON (column(length))// 创建表的时候同时创建索引CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , PRIMARY KEY (`id`), UNIQUE index_name (title(length))) 这里length的意思取字段的前几个字符建立索引，这样的好处是能够灵活控制索引的磁盘空间 主键索引PK一般为自增唯一字段，不允许为空 组合索引 从左到右，如果where不按这个顺序不会用索引 范围查询之后不会再用索引 跳跃查询也不会用索引全文索引","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://younfor.com/categories/MySQL/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://younfor.com/tags/技术栈/"},{"name":"MySQL","slug":"MySQL","permalink":"http://younfor.com/tags/MySQL/"}]},{"title":"Redis实战","slug":"Redis实战","date":"2018-06-11T04:55:17.000Z","updated":"2018-06-11T07:11:58.425Z","comments":true,"path":"Redis实战/","link":"","permalink":"http://younfor.com/Redis实战/","excerpt":"","text":"应用场景 当做缓存，缓存未命中再访问MySQL，这样能降低读的延迟 原子计数 最新TopN数据使用list中的LTRIM latest.comments 0 5000 这样永远只保存最近的5000个ID 带权值的排序使用sorted set， 然后ZADD命令 过期时间 优先级的队列系统 数据类型 List Set Sorted set Hash 自增原子特点 主从同步 持久化 strings12345struct sdshdr &#123; long len; long free; char buf[];&#125; set 1set name \"hello\" setnx其中nx是不存在的意思, 如果存在则设置失败 1setnx name \"hello\" setex如果超过10秒，get就会为空 1setex name 10 \"red\" setrange替换字符串 mset设置多组值 msetnx会回滚 getset返回旧值 mget获取多组数据，如果不存在返回nil incr/decr自增，如果不存在默认为1,而且用get的时候得到的会是字符串hashes hset 1hset myhash filed1 hello hsetnx如果key不存在则创建，如果key存在则返回0（不会覆盖） hmset设置多个filed hget 1hget myhash field1 hmget hincrby 12// 给指定的filed加定值hincrby myhash field3 -8 hexists 12//判断filed是否存在hexists myhash filed1 hlen返回filed的数量 hdel删除指定filed，并返回1 成功 hkeys hvals hgetalllists链表结构，主要只有push和pop, 是一个双向链表，长度为2的32次方，既可以当做栈也可以当做队列也有阻塞版本的pop lpush rpush 123// l和r是表示左右的意思lpush mylist \"world\"lrange mylist 0 -1 linsert 12// 在world前面加上therelinsert mylist3 before \"world\" \"there\" lset 12设置指定下标的值lset mylist 0 \"four\" lrem 123// 从 key 对应 list 中删除 count 个和 value 相同的元素// count &gt; 0 删除count， count &lt; 0 从尾部开始删除, count == 0删除所有lrem mylist 2 \"hello\" ltrim 12// 只保留from到to的数据ltrim mylist8 1 -1 // 相当于删除了第一个元素 lpop删除头部元素并返回头部元素 rpoplpush原子操作，从第一个链表取出来放到第二个链表头，并返回这个值 lindex 1lindex mylist index // 返回第index的位置 setsset 是集合， hashtable实现， sorted_set是跳表 sadd smemebers获取所有元素 srem删除 spop随机返回 sdiff去除 a里面和b相关，把剩下的返回比如 1 2 3 diff 3 4 5 = 1 2 sdiffstore12// 与sdiff的区别就是会存起来sdiffstore myset1 myset2 tomyset3 sinter sinterstore交集 sunion sunionstore并集 smove 12smove mysetfrom mysetto three// 把three从from移动到to scard返回元素个数 sismember返回是否是元素 srandmember随机返回，不删除 sorted sets排序的， 跳表+hashtable 12345zadd myzset 1 \"one\"zadd myzset 2 \"two\"zadd myzset 3 \"three\"zrange myzset 0 -1 withscores // zrevrange是从大到小的顺序// \"one\" \"1\" \"two\" \"2\" \"three\" \"3\" zincrby 1zincrby myset 2 \"one\" // 增加分数 zrank zrevrank从小到大返回 下标, 从大到小返回 下标 zrangebyscore zcount返回分数score区间的个数 zcard返回集合个数 zscore返回元素的score zremrangebyrank删除排名区间的， 下标顺序 zremrangebyscore删除score区间的元素 keys 列出所有key, 可以用字符串匹配 keys abc 之类 exists判断key是否存在 del删除key expire设置有效时间, 通过ttl获取有效时长 move转移数据库 12345select 0set age 30move age 1select 1get age persist移除过期时间 randomkey rename type获取key对应的value类型 ping info quit ..","categories":[{"name":"Redis","slug":"Redis","permalink":"http://younfor.com/categories/Redis/"}],"tags":[{"name":"技术栈","slug":"技术栈","permalink":"http://younfor.com/tags/技术栈/"},{"name":"Redis","slug":"Redis","permalink":"http://younfor.com/tags/Redis/"}]},{"title":"Go基础语法.md","slug":"Go基础语法","date":"2018-06-09T13:11:17.000Z","updated":"2018-06-11T04:48:37.687Z","comments":true,"path":"Go基础语法/","link":"","permalink":"http://younfor.com/Go基础语法/","excerpt":"","text":"编码风格gofmt一般会自动规范代码风格 ##注释&amp;驼峰命名/ 需要注释的内容 / 包名1import \"bytes\" 变量常量12345678910111213type ByteSize float64const ( _ = iota KB ByteSize = 1 &lt;&lt; (2 * iota) MB GB)// 主函数func main() &#123; fmt.Println(\"Hello World!\") fmt.Println(\"size %f\", GB) // size %f 64&#125; 声明1234var ( ErrInternal = errors.New(\"error1\") ErrInternal2 = errors.New(\"error2\")) 初始化Go语言提供了New和make new1234567891011121314151617181920// 0值初始化type SyncedBuffer struct &#123; lock sync.Mutex buffer bytes.Buffer&#125;p := new(SyncedBuffer) // type *SyncedBuffervar v SyncedBuffer // type SyncedBuffer// 如果是构造函数func NewFile(fd int, name string) *File &#123; if fd &lt; 0 &#123; return nil &#125; f := File&#123;fd, name, nil, 0&#125; // 如果不按顺序，就需要加名字 return &amp;f&#125;// 复合字面可以初始化多种结构a := [...]string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125;s := []string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125;m := map[int]string &#123;Enone: \"no error\", Eio: \"Eio\", Einval: \"invalid argument\"&#125; make`make一般用于初始化切片，映射，信道123make([]int, 10, 100)// 一般用法, 返回的不是指针v := make([]int, 100) 分支循环if12345678if i &lt; f() &#123; g()&#125;if err := file.Chmod(0664); err != nil &#123; log.Print(err) return err&#125; for1234567891011121314151617181920212223242526for init; condition; post &#123;&#125;for condition &#123;&#125;for &#123;&#125;// 举例sum := 0for i := 0; i &lt; 10; i++ &#123; sum += i&#125;// 遍历复合结构for key, value := range oldMap &#123; newMap[key] = value&#125;// 只遍历第一个for key := range oldMap &#123;&#125;// 只遍历第二个for _, value := range array &#123;&#125;// 遍历字符串for pos, char := range \"日本 \\ x80 语\" &#123; fmt.Printf()&#125;// 反转数字for i, j := 0, len(a) - 1; i &lt; j; i,j = i+1, j-1 &#123; a[i], a[j] = a[j], a[i]&#125; switch12345678910111213141516171819202122switch &#123;case '0' &lt;= c &amp;&amp; c &lt;= '9' : return c - '0'case 'a' &lt;= c &amp;&amp; c &lt;= 'f' : return c - 'a' + 10&#125;// 处理相同条件switch c &#123;case 'a', 'b', 'c': return true&#125;// 判断类型var t interface&#123;&#125;t = getType()switch t := t.(type) &#123;default : fmt.Printf(\"%T\", t)case bool : fmt.Printf(\"boolean %t\\n\", t)case int: fmt.Printf(\"integer %d\\n\", t)&#125; 函数多值返回1func (file *File) Write(b []byte) (n int, err error) defer无论何种路径都能返回，如果定义多个按定义顺序相反顺序执行 切片(数组)123456789// 切片是按值传递，但是底层可能是同一份数组// 二维切片type Transform [3][3]float64type LinesOfText [][]bytetest := LinesOfTest&#123; []byte(\"abc\"), []byte(\"abc\"), []byte(\"abc\"),&#125; append12345678// 增加元素x := []int&#123;1,2,3&#125;x = append(x, 4, 5, 6)fmt.Println(x)// 增加切片y := []int&#123;1,2,3&#125;x = append(x, y...)fmt.Println(x) Map映射1234567891011121314attend := map[string]bool&#123; \"Ann\" : true, \"Joe\" : true, ...&#125;// 判断是否存在var seconds intvar ok boolseconds, ok = timeZone[tz]if _, ok := timeZone[tz]; ok &#123; doSomething()&#125;// 删除映射delete(timeZone, \"PDT\") 初始化方式：File{fd, name, nil, 0}File{fd: fd, name: name}make([]int, 100) 函数init在变量初始化之后，导入包初始化之后，就会初始化`以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用。 接口断言12345str, ok := value.(string)if ok &#123; fmt.Printf(\"\")&#125; else &#123;&#125; 内嵌1234567891011121314151617// 接口type Reader interface &#123; Read(p []byte) (n int, err error)&#125;type Writer interface &#123; Write(p []byte) (n int, err error)&#125;type ReaderWriter interface &#123; Reader Writer&#125;// 结构体type ReaderWriter struct &#123; *Reader *Writer&#125; 并发chan123cj := make(chan int) // 无缓冲信道cj := make(chan int, 0) // 无缓冲信道cj := make(chan *os.File, 100) // 指向文件指针的带缓冲信道 例子12345678910111213141516171819c := make(chan int)go func() &#123; list.Sort() c &lt;- 1&#125;()doSomethingForAWhile()&lt;- c// 考虑带缓冲的任务func Serve(queue chan *Request) &#123; for req := range queue &#123; req := req sem &lt;- 1 go func() &#123; process(req) &lt;-sem &#125;() &#125;&#125; panic&amp;recover","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://younfor.com/categories/Go语言/"}],"tags":[]},{"title":"Go高级编程.md","slug":"Go高级编程","date":"2018-06-09T03:11:17.000Z","updated":"2018-06-11T04:48:37.687Z","comments":true,"path":"Go高级编程/","link":"","permalink":"http://younfor.com/Go高级编程/","excerpt":"","text":"https://books.studygolang.com/advanced-go-programming-book/ch2-cgo/ch2-04-memory.html 数组数组定义方式1234567var a [3]int // 定义一个长度为3的int类型数组, 元素全部为0var b = [...]int&#123;1, 2, 3&#125; // 定义一个长度为3的int类型数组, 元素为 1, 2, 3var c = [...]int&#123;2: 3, 1: 2&#125; // 定义一个长度为3的int类型数组, 元素为 0, 2, 3var d = [...]int&#123;1, 2, 4: 5, 6&#125; // 定义一个长度为6的int类型数组, 元素为 1, 2, 0, 0, 5, 6 数组指针123456789101112131415var a = [...]int&#123;1, 2, 3&#125; // a 是一个数组var b = &amp;a // b 是指向数组的指针fmt.Println(a[0], a[1]) // 打印数组的前2个元素fmt.Println(b[0], b[1]) // 通过数组指针访问数组元素的方式和数组类似for i, v := range b &#123; // 通过数组指针迭代数组的元素 fmt.Println(i, v)&#125; 数组遍历1234567891011121314151617for i := range a &#123; fmt.Printf(\"b[%d]: %d\\n\", i, b[i])&#125;for i, v := range b &#123; fmt.Printf(\"b[%d]: %d\\n\", i, v)&#125;for i := 0; i &lt; len(c); i++ &#123; fmt.Printf(\"b[%d]: %d\\n\", i, b[i])&#125; 函数数组、管道数组1234567891011121314151617181920212223// 图像解码器数组var decoder1 [2]func(io.Reader) (image.Image, error)var decoder2 = [...]func(io.Reader) (image.Image, error)&#123; png.Decode, jpeg.Decode,&#125;// 接口数组var unknown1 [2]interface&#123;&#125;var unknown2 = [...]interface&#123;&#125;&#123;123, \"你好\"&#125;// 管道数组var chanList = [2]chan int&#123;&#125; 空数组长度为0的数组在内存中并不占用空间。空数组虽然很少直接使用，但是可以用于强调某种特有类型的操作时避免分配额外的内存空间，比如用于管道的同步操作：1234567891011c1 := make(chan [0]int)go func() &#123; fmt.Println(\"c1\") c1 &lt;- [0]int&#123;&#125;&#125;()&lt;-c1 在这里，我们并不关心管道中传输数据的真实类型，其中管道接收和发送操作只是用于消息的同步。对于这种场景，我们用空数组来作为管道类型可以减少管道元素赋值时的开销。当然一般更倾向于用无类型的匿名结构体代替：1234567891011c2 := make(chan struct&#123;&#125;)go func() &#123; fmt.Println(\"c2\") c2 &lt;- struct&#123;&#125;&#123;&#125; // struct&#123;&#125;部分是类型, &#123;&#125;表示对应的结构体值&#125;()&lt;-c2 字符串类似切片字符串虽然不是切片，但是支持切片操作，不同位置的切片底层也访问的同一块内存数据（因为字符串是只读的，相同的字符串面值常量通常是对应同一个字符串常量）：12345678910s := \"hello, world\"hello := s[:5]world := s[7:]s1 := \"hello, world\"[:5]s2 := \"hello, world\"[7:] 和数组一样，内置的len和cap函数返回相同的结果，都对应字符串的长度。也可以通过reflect.StringHeader结构访问字符串的长度（这里只是为了演示字符串的结构，并不是推荐的做法）：12345fmt.Println(\"len(s):\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s)).Len) // 12fmt.Println(\"len(s1):\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s1)).Len) // 5fmt.Println(\"len(s2):\", (*reflect.StringHeader)(unsafe.Pointer(&amp;s2)).Len) // 5 切片(slice)1234567891011121314151617181920212223var ( a []int // nil切片, 和 nil 相等, 一般用来表示一个不存在的切片 b = []int&#123;&#125; // 空切片, 和 nil 不相等, 一般用来表示一个空的集合 c = []int&#123;1, 2, 3&#125; // 有3个元素的切片, len和cap都为3 d = c[:2] // 有2个元素的切片, len为2, cap为3 e = c[0:2:cap(c)] // 有2个元素的切片, len为2, cap为3 f = c[:0] // 有0个元素的切片, len为0, cap为3 g = make([]int, 3) // 有3个元素的切片, len和cap都为3 h = make([]int, 2, 3) // 有2个元素的切片, len为2, cap为3 i = make([]int, 0, 3) // 有0个元素的切片, len为0, cap为3)``## 添加切片 var a []int a = append(a, 1) // 追加1个元素 a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式 a = append(a, []int{1,2,3}…) // 追加一个切片, 切片需要解包 1`在容量不足的情况下，append的操作会导致重新分配内存，从而导致巨大的内存分配和复制数据代价` var a = []int{1,2,3} a = append([]int{0}, a…) // 在开头添加1个元素 a = append([]int{-3,-2,-1}, a…) // 在开头添加1个切片1234567891011```var a []inta = append(a[:i], append([]int&#123;x&#125;, a[i:]...)...) // 在第i个位置插入xa = append(a[:i], append([]int&#123;1,2,3&#125;, a[i:]...)...) // 在第i个位置插入切片a = append(a, x...) // 为x切片扩展足够的空间copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置copy(a[i:], x) // 复制新添加的切片 删除切片需要重新赋值切片防止内存泄漏123456789func FindPhoneNumber(filename string) []byte &#123; b, _ := ioutil.ReadFile(filename) b = regexp.MustCompile(\"[0-9]+\").Find(b) return append([]byte&#123;&#125;, b...) // 这里&#125; 删除切片有时候会影响GC12345678var a []*int&#123; ... &#125;a = a[:len(a)-1] // 本删除的最后一个元素依然被引用, 可能导致GC操作被阻碍var a []*int&#123; ... &#125;a[len(a)-1] = nil // GC回收最后一个元素内存a = a[:len(a)-1] // 从切片删除最后一个元素 可以用copy和append组合可以避免创建中间的临时切片，同样是完成添加元素的操作：12345a = append(a, 0) // 切片扩展1个空间copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置s[i] = x // 设置新添加的元素 第一句append用于扩展切片的长度，为要插入的元素留出空间。第二句copy操作将要插入位置开始之后的元素向后挪动一个位置。第三句真实地将新添加的元素赋值到对应的位置。操作语句虽然冗长了一点，但是相比前面的方法，可以减少中间创建的临时切片。用copy和append组合也可以实现在中间位置插入多个元素(也就是插入一个切片):12345a = append(a, x...) // 为x切片扩展足够的空间copy(a[i+len(x):], a[i:]) // a[i:]向后移动len(x)个位置copy(a[i:], x) // 复制新添加的切片 也可以用copy完成删除开头的元素：12345a = []int&#123;1, 2, 3&#125;a = a[:copy(a, a[1:])] // 删除开头1个元素a = a[:copy(a, a[N:])] // 删除开头N个元素 对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用append或copy原地完成：1234567891011a = []int&#123;1, 2, 3, ...&#125;a = append(a[:i], a[i+1:]...) // 删除中间1个元素a = append(a[:i], a[i+N:]...) // 删除中间N个元素a = a[:copy(a[i:], a[i+1:])] // 删除中间1个元素a = a[:copy(a[i:], a[i+N:])] // 删除中间N个元素 并发模型加锁12345678var total struct &#123; sync.Mutex value int&#125;通过sync.lock()和sync.Done() 原子1234567891011121314151617181920212223242526272829303132333435363738import ( \"sync\" \"sync/atomic\")//用法：func worker(wg *sync.WaitGroup) &#123; defer wg.Done() var i uint64 for i = 0; i &lt;= 100; i++ &#123; atomic.AddUint64(&amp;total, i) &#125;&#125;func main() &#123; var wg sync.WaitGroup wg.Add(2) go worker(&amp;wg) go worker(&amp;wg) wg.Wait()&#125; 单例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455我们可以将通用的代码提取出来，就成了标准库中sync.Once的实现：type Once struct &#123; m Mutex done uint32&#125;func (o *Once) Do(f func()) &#123; if atomic.LoadUint32(&amp;o.done) == 1 &#123; return &#125; o.m.Lock() defer o.m.Unlock() if o.done == 0 &#123; defer atomic.StoreUint32(&amp;o.done, 1) f() &#125;&#125;基于sync.Once重新实现单件模式：var ( instance *singleton once sync.Once)func Instance() *singleton &#123; once.Do(func() &#123; instance = &amp;singleton&#123;&#125; &#125;) return instance&#125; 带缓冲chan测试了下才知道原来&lt;-chan int 像这样的只能接收值chan&lt;- int 像这样的只能发送值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var limit = make(chan int, 3)func main() &#123; for _, w := range work &#123; go func() &#123; limit &lt;- 1 w() &lt;-limit &#125;() &#125; select&#123;&#125;&#125;func main() &#123; done := make(chan int, 10) // 带 10 个缓存 // 开N个后台打印线程 for i := 0; i &lt; cap(done); i++ &#123; go func()&#123; fmt.Println(\"你好, 世界\") done &lt;- 1 &#125;() &#125; // 等待N个后台线程完成 for i := 0; i &lt; cap(done); i++ &#123; &lt;-done &#125;&#125;//其实也可以用sync.WaitGroup select12345678910111213141516171819202122232425262728293031323334基于select实现的管道的超时判断： select &#123; case v := &lt;-in: fmt.Println(v) case &lt;-time.After(time.Second): return // 超时 &#125;通过select的default分支实现非阻塞的管道发送或接收操作： select &#123; case v := &lt;-in: fmt.Println(v) default: // 没有数据 &#125;通过select来阻止main函数退出：func main() &#123; // do some thins select&#123;&#125;&#125; 但是管道的发送操作和接收操作是一一对应的，如果要停止多个Goroutine那么可能需要创建同样数量的管道，这个代价太大了。其实我们可以通过close关闭一个管道来实现广播的效果，所有从关闭管道接收的操作均会收到一个零值和一个可选的失败标志。12345678910111213141516171819202122232425262728293031323334353637383940func worker(cannel chan bool) &#123; for &#123; select &#123; default: fmt.Println(\"hello\") // 正常工作 case &lt;-cannel: // 退出 &#125; &#125;&#125;func main() &#123; cancel := make(chan bool) for i := 0; i &lt; 10; i++ &#123; go worker(cancel) &#125; time.Sleep(time.Second) close(cancel)&#125; 异常异常必须放在defer func () {}()","categories":[{"name":"Go语言","slug":"Go语言","permalink":"http://younfor.com/categories/Go语言/"}],"tags":[{"name":"Go","slug":"Go","permalink":"http://younfor.com/tags/Go/"}]}]}